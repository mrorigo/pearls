// Rust guideline compliant 2026-02-06

//! Identity module for hash-based ID generation and resolution.
//!
//! This module provides functionality for generating collision-resistant
//! hash-based IDs and resolving partial IDs.

use crate::{Error, Pearl, Result};
use sha2::{Digest, Sha256};

/// Generates a hash-based ID for a Pearl.
///
/// The ID is generated by computing a SHA-256 hash of the concatenation of
/// title, author, timestamp, and nonce. The hash is then truncated to 6-8
/// hexadecimal characters and prefixed with "prl-".
///
/// # Arguments
///
/// * `title` - The Pearl title
/// * `author` - The author identifier
/// * `timestamp` - Unix timestamp
/// * `nonce` - Nonce for collision avoidance
///
/// # Returns
///
/// A hash-based ID in the format "prl-XXXXXX" where X is a hexadecimal character.
///
/// # Examples
///
/// ```
/// use pearls_core::identity::generate_id;
///
/// let id = generate_id("Fix bug", "alice", 1704067200, 0);
/// assert!(id.starts_with("prl-"));
/// assert!(id.len() >= 10 && id.len() <= 12); // "prl-" + 6-8 hex chars
/// ```
pub fn generate_id(title: &str, author: &str, timestamp: i64, nonce: u32) -> String {
    let mut hasher = Sha256::new();

    // Hash the concatenation of title, author, timestamp, and nonce
    hasher.update(title.as_bytes());
    hasher.update(author.as_bytes());
    hasher.update(timestamp.to_le_bytes());
    hasher.update(nonce.to_le_bytes());

    let hash = hasher.finalize();

    // Convert to hex string and truncate to 6 characters
    // (can be extended to 8 if needed for collision avoidance)
    let hex = format!("{:x}", hash);
    let truncated = &hex[..6];

    format!("prl-{}", truncated)
}

/// Validates that an ID matches the expected format.
///
/// The expected format is "prl-" followed by 6-8 hexadecimal characters (lowercase).
///
/// # Arguments
///
/// * `id` - The ID to validate
///
/// # Returns
///
/// Ok if the ID is valid, Err otherwise.
///
/// # Errors
///
/// Returns an error if the ID does not match the format "prl-[0-9a-f]{6,8}".
///
/// # Examples
///
/// ```
/// use pearls_core::identity::validate_id_format;
///
/// assert!(validate_id_format("prl-abc123").is_ok());
/// assert!(validate_id_format("prl-12345678").is_ok());
/// assert!(validate_id_format("invalid").is_err());
/// assert!(validate_id_format("prl-12345").is_err()); // Too short
/// ```
pub fn validate_id_format(id: &str) -> Result<()> {
    // Check if ID starts with "prl-"
    if !id.starts_with("prl-") {
        return Err(Error::InvalidPearl(format!(
            "ID must start with 'prl-', got '{}'",
            id
        )));
    }

    // Extract the hash portion
    let hash_part = &id[4..];

    // Check length (6-8 characters)
    if hash_part.len() < 6 || hash_part.len() > 8 {
        return Err(Error::InvalidPearl(format!(
            "ID hash must be 6-8 characters, got {} characters",
            hash_part.len()
        )));
    }

    // Check that all characters are lowercase hexadecimal
    if !hash_part
        .chars()
        .all(|c| c.is_ascii_digit() || ('a'..='f').contains(&c))
    {
        return Err(Error::InvalidPearl(format!(
            "ID hash must contain only lowercase hexadecimal characters (0-9, a-f), got '{}'",
            hash_part
        )));
    }

    Ok(())
}

/// Resolves a partial ID to a full Pearl ID.
///
/// This function searches through a list of Pearls to find matches for a partial ID.
/// The partial ID must be at least 3 characters long and match the beginning of a
/// Pearl's ID.
///
/// # Arguments
///
/// * `partial` - The partial ID to resolve (minimum 3 characters)
/// * `pearls` - The list of Pearls to search through
///
/// # Returns
///
/// The full ID if exactly one match is found.
///
/// # Errors
///
/// Returns an error if:
/// - The partial ID is less than 3 characters
/// - No Pearls match the partial ID
/// - Multiple Pearls match the partial ID (ambiguous)
///
/// # Examples
///
/// ```
/// use pearls_core::identity::resolve_partial_id;
/// use pearls_core::Pearl;
///
/// let pearls = vec![
///     Pearl::new("Task 1".to_string(), "alice".to_string()),
///     Pearl::new("Task 2".to_string(), "bob".to_string()),
/// ];
///
/// // Assuming the first pearl has ID "prl-abc123"
/// // resolve_partial_id("prl-abc", &pearls) would return Ok("prl-abc123")
/// ```
pub fn resolve_partial_id(partial: &str, pearls: &[Pearl]) -> Result<String> {
    // Require minimum 3 characters for partial ID matching
    if partial.len() < 3 {
        return Err(Error::InvalidPearl(
            "Partial ID must be at least 3 characters".to_string(),
        ));
    }

    // Find all Pearls whose IDs start with the partial ID
    let matches: Vec<&str> = pearls
        .iter()
        .filter(|p| p.id.starts_with(partial))
        .map(|p| p.id.as_str())
        .collect();

    match matches.len() {
        0 => {
            // No matches - suggest similar IDs
            let similar: Vec<String> = pearls
                .iter()
                .filter(|p| p.id.contains(&partial[..partial.len().min(4)]))
                .take(3)
                .map(|p| p.id.clone())
                .collect();

            if similar.is_empty() {
                Err(Error::NotFound(format!("Pearl '{}' not found", partial)))
            } else {
                Err(Error::NotFound(format!(
                    "Pearl '{}' not found. Did you mean: {}?",
                    partial,
                    similar.join(", ")
                )))
            }
        }
        1 => {
            // Exactly one match - success
            Ok(matches[0].to_string())
        }
        _ => {
            // Multiple matches - ambiguous
            Err(Error::AmbiguousId(
                partial.to_string(),
                matches.iter().map(|s| s.to_string()).collect(),
            ))
        }
    }
}
